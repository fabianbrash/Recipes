
######My kubernetes journey#################################
##REF:https://kubernetes.io/docs/tasks/


kubectl version
kubectl version --short
kubectl api-versions

kubectl get namespaces
kubectl get namespaces -A ##get all namespaces even system namespaces by default all your pods are created in the default namespace
kubectl get pods
kubectl get deployments
kubectl get services or kubectl get svc

##Get current context
kubectl config view
kubectl config current-context

#kubectl get - list resources
#kubectl describe - show detailed information about a resource
#kubectl logs - print the logs from a container in a pod
#kubectl exec - execute a command on a container in a pod

####After you create a deployment you can create a service so external users can access it
##But first after we deploy our deployment lets get the IP of the pods
kubectl get pods -o wide

###or to specify a label from our deployment
kubectl get pods -l app=nginx -o wide

##you can expose the service with
kubectl expose deployment/nginx-deployment

##or with a yaml file check my yaml repo

####Run a simple deployment without a yaml file
kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080

##delete the deployment 
kubectl get deployments
kubectl delete deployement 'our deployment name'


###you can run the kubectl proxy command but it's best to look at services
kubectl proxy ##run in a different terminal
curl http://localhost:8001/version

###delete deployment
kubectl delete deployment my-deployment

###Create a custom namespace#############
#REF:https://www.assistanz.com/steps-to-create-custom-namespace-in-the-kubernetes/
kubectl create namespace mynamespace

###YAML###########
apiVersion: v1
kind: Namespace
metadata:
   name: mynamespace
   
##END YAML

###Deploy a pod into our namespace
kubectl run ns-pod --image=nginx --port=80 --generator=run-pod/v1 -n mynamespace

kubectl get pods --namespace mynamespace

##Delete the pods in the namespace
kubectl delete pods --all --namespace mynamespace

##Delete namespace
kubectl delete namespace mynamespace

###Add to our .kube/config so we can switch namespaces
#REF:https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/

##Get current context
kubectl config view
kubectl config current-context

##You populate the below from the results of the 2 commands above

kubectl config set-context dev --namespace=development \
  --cluster=lithe-cocoa-92103_kubernetes \
  --user=lithe-cocoa-92103_kubernetes

kubectl config set-context prod --namespace=production \
  --cluster=lithe-cocoa-92103_kubernetes \
  --user=lithe-cocoa-92103_kubernetes


kubectl config view

kubectl config use-context dev

kubectl config current-context

####Now switch to prod
kubectl config use-context prod



#########################KUBERNETES INSTALL NOTES####################################################
###I will turn this into a bash script soon and then hopefully an ansible playbook####
##Thanks to REF:https://github.com/justmeandopensource/kubernetes/blob/master/docs/install-cluster.md

su -

##edit hosts file
cat >>/etc/hosts<<EOF
192.168.50.104 k8master.itbu.ad.enterprise.com k8master
192.168.50.105 k8worker01.itbu.ad.enterprise.com k8worker01
EOF

##Install docker
yum install -y yum-utils device-mapper-persistent-data lvm2

yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

yum install -y docker-ce

systemctl enable docker
systemctl start docker

##disable selinux
setenforce 0
sed -i --follow-symlinks 's/^SELINUX=enforcing/SELINUX=disabled/' /etc/sysconfig/selinux

##Disable firewalld
systemctl disable firewalld
systemctl stop firewalld

##Disable swap
sed -i '/swap/d' /etc/fstab
swapoff -a

##Update sysctl settings for Kubernetes networking

cat >>/etc/sysctl.d/kubernetes.conf<<EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sysctl --system


##Kubernetes Setup

##Add yum repository
##Note the indentation for gpgkey is vital or this will fail installing kubelet

cat >>/etc/yum.repos.d/kubernetes.repo<<EOF
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF

##Install kubernetes
yum install -y kubeadm kubelet kubectl

## Enable and Start kubelet service
systemctl enable kubelet
systemctl start kubelet


##Initialize Kubernetes Cluster

kubeadm init --apiserver-advertise-address=192.168.50.104 --pod-network-cidr=10.244.0.0/16


##Run the command as root our using sudo

kubeadm join 192.168.50.104:6443 --token jpffga.v6rwru1tv5euqj2n \
    --discovery-token-ca-cert-hash sha256:df00931ffc172d6206eeccf9edf40ca632e7ce6ebeed2eab4e5b2989b4481976



###Copy kube config
##To be able to use kubectl command to connect and interact with the cluster, the user needs kube config file.

mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

##Deploy flannel network
##this is done with the above user
##Note if you have more than 1 interfaces then you will have to first download the yml file and make an edit to it
## find --iface and set to eth1(or whatever)
##modified yml file @ 


####Look for
containers:
      - name: kube-flannel
        image: quay.io/coreos/flannel:v0.10.0-amd64
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        - --iface=eth1
###################################################################



https://raw.githubusercontent.com/justmeandopensource/kubernetes/master/vagrant-provisioning/kube-flannel.yml

kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml



###Cluster join command
##If you didn't save the output from the cluster creation
kubeadm token create --print-join-command


##ALL done

kubectl get pods
kubectl version --short
kubectl get componentstatus or kubectl get cs

